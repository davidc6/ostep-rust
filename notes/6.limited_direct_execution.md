# Limited Direct Execution

The OS needs to somehow share the CPU when running many jobs at the same time. 
In order to do that it needs to virtualise the CPU and use a technique called 
time sharing to run many processes concurrently. 

There are performance (i.e. how to efficiently virtualise the CPU?) and control 
(i.e. how to retain control over the CPU while running processes efficiently?) 
challenges that need to be take care of. 

The direct execution model is when program runs directly on the CPU. There a number 
of issues with this approach. How can we make sure that the process does not take 
unexpected actions and how can the OS stop it and switch to another process. This is 
essentially **time sharing** required to implement the CPU.

If a process wants to perform a restricted operation (disk I/O request, access 
system resources like CPU or memory, etc) without a proper design it essentially 
can be free whatever it wants in system which is far away from ideal.

**User mode** is a processor mode that restricts code that runs in user mode. If 
it tries to do that, it would result in a raised exception.

**Kernel mode** is a mode that the kernel / operating system runs in. In this mode 
code can do whatever it wants. 

If a user mode process needs to perform a task that requires elevated privilege 
access, it needs to perform a **system call**. The kernel exposes certain key pieces 
of functionality to user programs (e.g. file system access, process creation and 
destruction, inter-process communication, etc.).

The program executes a special **trap** instruction which jumps into the kernel 
and raises the privilege level to kernel mode. Once in the kernel the process can 
perform privileged operations. Once finished, the OS calls a special **return-from-trap** 
instruction which returns to the user privilege mode.

The hardware must save enough of the processors registers in order to return back 
when the OS issues return-from-trap instruction. A **kernel stack** is used to store 
such information (e.g. program counter, flags etc.) which is popped when return-from-trap 
is called to resume the execution of the user program. These concepts are the same 
across different architectures (terminology might differ). 

A **trap table** is set up in kernel mode at boot time. It contains information to tell 
the hardware what code to run when a certain exception (hardware disk interrupt, 
keyboard interrupt or a system call) occurs. The OS informs the hardware of the 
locations of these **trap handlers** (with some special instruction). The hardware 
remembers the location of these (until the machine reboots) and knows what to do.



## Summary

- **trap** instruction - raises privilege to kernel mode and 
